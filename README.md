# ITBase: Система учета и управления ИТ-активами

ITBase — это веб-приложение, разработанное для инвентаризации, отслеживания и управления жизненным циклом ИТ-активов в организации.

## Технологический стек

- **Бэкенд:** Python 3.11+ / FastAPI
- **База данных:** PostgreSQL
- **ORM и миграции:** SQLAlchemy 2.0 (асинхронный) / Alembic
- **Валидация данных:** Pydantic
- **Фронтенд:** Jinja2 / HTML / Bootstrap 5
- **Окружение:** Venv (локально), Docker / Docker Compose (продакшн)

---

## Быстрый старт (для локальной разработки)

1. **Клонировать репозиторий:**

   ```bash
   git clone https://github.com/LelikTrue/ITBase-.git
   cd ITBase-
   ```

2. **Создать и активировать виртуальное окружение:**

   ```bash
   python -m venv venv
   source venv/bin/activate  # Для Windows: venv\Scripts\activate
   ```

3. **Настроить переменные окружения:**

   - Скопируйте файл `.env.example` в новый файл `.env`
   - Заполните `.env` актуальными данными для подключения к вашей локальной базе данных PostgreSQL. Приложение использует отдельные переменные для сборки строки подключения:

     ```env
     DB_HOST=localhost
     DB_NAME=itbase_db
     DB_USER=your_user
     DB_PASSWORD=your_password
     DB_PORT=5432
     ```

4. **Установить зависимости и применить миграции:**
   - Убедитесь, что база данных, указанная в `.env`, создана.
   - Выполните команду, которая установит все зависимости и подготовит базу данных:

   ```bash
   python run_dev.py --install --migrate
   ```

5. **(Опционально) Заполнить базу демо-данными:**

   Чтобы сразу начать работу с предзаполненным приложением, выполните два скрипта в указанном порядке.

   - **Шаг 1: Создание справочников** (типы, статусы, производители и т.д.):

     ```bash
     python init_data.py
     ```

   - **Шаг 2: Генерация тестовых активов** (создает 30 случайных устройств):

     ```bash
     python seed_devices.py
     ```

6. **Запустить сервер:**
   Для запуска сервера разработки используйте скрипт `run_dev.py`. Он универсален для всех операционных систем.

   ```bash
   python run_dev.py
   ```

   Приложение будет доступно по адресу `http://localhost:8000`.

---

## � Запуск через Docker

Этот способ используется для запуска всего стека (приложение + база данных) в изолированных контейнерах.

1. **Предварительные требования:**
   - Установленные Docker и Docker Compose

2. **Настройка переменных окружения:**

   - Скопируйте файл `.env.example` в `.env`
   - Убедитесь, что `DB_HOST` указывает на имя сервиса базы данных из `docker-compose.yml` (по умолчанию `db`)

3. **Сборка и запуск:**

   ```bash
   docker compose up -d --build
   ```

   Приложение будет доступно по адресу `http://localhost:8000`.

4. **Применить миграции:**

   ```bash
   docker compose exec backend alembic upgrade head
   ```

5. **(Опционально) Заполнить базу демо-данными:**
   - **Шаг 1: Создание справочников:**

     ```bash
     docker compose exec backend python init_data.py
     ```

   - **Шаг 2: Генерация тестовых активов:**

     ```bash
     docker compose exec backend python seed_devices.py
     ```

---

## Архитектура и ключевые принципы

Мы придерживаемся многоуровневой архитектуры для четкого разделения ответственности.

### 1. Принцип "Тонкие роутеры, толстые сервисы"

Это наш главный архитектурный принцип.

### Слой API / Роутеры (`app/api/endpoints/`)

- **Ответственность:** Только обработка HTTP-запросов и ответов
- **Что здесь происходит:**
  - Прием запроса
  - Валидация данных через Pydantic-схемы (с помощью `Depends`)
  - Вызов соответствующего метода сервиса
  - Обработка исключений от сервисного слоя
  - Формирование HTTP-ответа (данные или код ошибки)

- **Чего здесь НЕ должно быть:**
  - Бизнес-логики
  - Прямых запросов к БД
  - Управления транзакциями (`db.commit()`)

### Сервисный слой (`app/services/`)

- **Ответственность:** Вся бизнес-логика приложения
- **Что здесь происходит:**
  - Координация операций
  - Реализация бизнес-правил (например, "нельзя удалить модель, если она используется")
  - Управление транзакциями
  - Вызов моделей для работы с данными
  - Логирование действий

  Это "мозг" приложения.

### 2. Валидация данных через Pydantic (`app/schemas/`)

- Все данные, входящие в API и выходящие из него, должны проходить через Pydantic-схемы.
- Схемы служат "контрактом" нашего API, гарантируя строгую типизацию и валидацию данных на входе.
- Мы используем `ConfigDict(from_attributes=True)` для легкого преобразования SQLAlchemy-моделей в Pydantic-схемы.

### 3. Атомарность операций

- Любая бизнес-операция, затрагивающая несколько записей в БД (например, создание актива и запись в лог аудита), должна выполняться в рамках одной транзакции.
- Управление транзакциями (`db.commit()`, `db.rollback()`) происходит исключительно на сервисном слое.

### Ключевые архитектурные паттерны

В дополнение к общим принципам, мы используем несколько конкретных паттернов для ускорения разработки и повышения надежности:

1. **Два типа сервисов:**
    - **Универсальный сервис (`DictionaryService`):**
    Используется для всех простых справочников (`AssetType`, `Location` и т.д.). Он принимает тип модели в конструкторе и предоставляет стандартный CRUD, избавляя от дублирования кода.
    - **Специализированные сервисы (`DeviceModelService`, `EmployeeService`):**
    Создаются для сущностей с уникальной бизнес-логикой (например, проверка связанных по внешнему ключу сущностей или сложная обработка ошибок).

2. **Коммуникация через исключения:**
    - Сервисный слой сообщает роутеру о бизнес-ошибках (например, "запись уже существует" или "нельзя удалить, так как есть зависимости"), выбрасывая кастомные исключения из `app/services/exceptions.py` (например, `DuplicateError`, `DeletionError`).
    - Роутер ловит эти исключения и преобразует их в соответствующие HTTP-статусы (`409 Conflict`, `404 Not Found` и т.д.).

3. **Надежные базовые модели:**

   - Наша базовая модель `BaseMixin` (`app/models/base.py`) использует одновременно `default` (для Python) и `server_default` (для БД) для полей `created_at` и `updated_at`. Это гарантирует, что у экземпляра модели всегда есть временная метка, даже до сохранения в базу данных, что упрощает логику и логирование.

---

## Работа с базой данных (Миграции Alembic)

Alembic используется для управления схемой базы данных.

### Создание новой миграции

После внесения изменений в модели SQLAlchemy (`app/models/`) необходимо сгенерировать файл миграции:

```bash
alembic revision --autogenerate -m "Краткое описание изменений"
```

> **Важно:** Всегда проверяйте сгенерированный файл миграции перед применением.

#### Применение миграций

```bash
alembic upgrade head
```

---

## Пример рабочего процесса: Добавление нового CRUD

1. **Схема (`app/schemas/`):** Определить Pydantic-схемы для создания, обновления и ответа (`Create`, `Update`, `Response`)
2. **Модель (`app/models/`):** Если нужно, внести изменения в модель SQLAlchemy
3. **Миграция:** Создать и применить миграцию Alembic
4. **Сервис (`app/services/`):** Создать или дополнить сервис, реализовав в нем всю бизнес-логику для новой сущности (CRUD-методы, проверки и т.д.)
5. **Роутер (`app/api/endpoints/`):** Добавить "тонкие" эндпоинты, которые вызывают методы сервиса
6. **Тестирование:** Убедиться, что новые эндпоинты работают корректно через Swagger UI (`/docs`)

---

## Соглашение о коммитах (Conventional Commits)

Мы придерживаемся стандарта Conventional Commits для ведения истории изменений. Это позволяет нам поддерживать историю в чистоте и автоматизировать создание списков изменений.

### Формат сообщения

```text
<type>(<scope>): <subject>
```

Основные типы (`type`):

- `feat`: Новая функциональность.
- `fix`: Исправление бага.
- `refactor`: Рефакторинг кода без изменения его поведения.
- `docs`: Изменения в документации.
- `style`: Форматирование кода.
- `test`: Работа с тестами.
- `chore`: Рутинные задачи (сборка, зависимости).

Примеры:

- `feat(services): add EmployeeService with full CRUD`
- `refactor(api): move dictionary logic from router to services`
- `docs: create initial README.md with project overview`
